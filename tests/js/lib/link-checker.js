/*

    A component that trawls our generated content and reports errors if there are:

    1. Broken links between pages on the site.
    2. Broken links within a single page.

    Fires `onResultsAvailable` when the report is ready.  This event is fired with the report content itself.  The
    report content is generated by transforming the component using `fluid.model.transformWithRules` and
    `that.options.rules.report`.  By default, this report looks something like:

    {
        errors: [
            { page: "path/to/page/filename.md", link: "page2.html#link" }
        ]
    }

 */
/* eslint-env node */
"use strict";
var fluid   = require("infusion");
var request = require("request");
var url     = require("url");
var jsdom   = require("jsdom");

fluid.registerNamespace("fluid.tests.docs.linkChecker");

fluid.tests.docs.linkChecker.startScan = function (that) {
    var startingUrl = fluid.tests.docs.linkChecker.resolveSafely(that.options.baseUrl, that.options.startPage);

    that.pagesToScan.push(startingUrl);

    that.scanSinglePageOrFinish();
};

fluid.tests.docs.linkChecker.scanSinglePageOrFinish = function (that) {
    if (that.pagesToScan.length) {
        var promise = fluid.promise();
        promise.then(that.scanSinglePageOrFinish);

        var pageToScan = that.pagesToScan.pop();
        if (that.scannedPages[pageToScan]) {
            // Skip this, we've already scanned it.
            promise.resolve();
        }
        else {
            // Retrieve the page and process it.
            request(pageToScan, function (error, response, body) {
                fluid.tests.docs.linkChecker.processSingleResponse(that, pageToScan, error, response, body);
                promise.resolve();
            });
        }
    }
    else {
        fluid.tests.docs.linkChecker.checkInternalLinks(that);
        fluid.tests.docs.linkChecker.checkPageLinks(that);

        var report = fluid.tests.docs.linkChecker.generateReport(that);
        that.events.onResultsAvailable.fire(report);
    }
};

fluid.tests.docs.linkChecker.urlBeforeHash = function (link) {
    return link.indexOf("#") !== -1 ? link.substring(0, link.indexOf("#")) : link;
};

fluid.tests.docs.linkChecker.urlAfterHash = function (link) {
    return link.indexOf("#") !== -1 ? link.substring(link.indexOf("#") + 1) : "";
};

fluid.tests.docs.linkChecker.checkInternalLinks = function (that) {
    fluid.each(that.internalLinksToCheck, function (link) {
        var linkBeforeHash = fluid.tests.docs.linkChecker.urlBeforeHash(link);
        var linkAfterHash  = fluid.tests.docs.linkChecker.urlAfterHash(link);
        if (linkAfterHash && linkAfterHash.length) {
            var pageIds = that.idsByPage[linkBeforeHash];
            if (!pageIds || pageIds.indexOf(linkAfterHash) === -1 && that.brokenLinks.indexOf(link) === -1) {
                that.brokenLinks.push(link);
            }
        }
    });
};

fluid.tests.docs.linkChecker.checkPageLinks = function (that) {
    fluid.each(that.scannedPages, function (results, page) {
        if (results.error || results.statusCode !== 200 && that.brokenLinks.indexOf(page) === -1) {
            that.brokenLinks.push(page);
        }
    });
};

fluid.tests.docs.linkChecker.resolveSafely = function (baseUrl, path) {
    var cleanPath = path.replace(/^about:blank/i, "");
    return url.resolve(baseUrl, cleanPath);
};

fluid.tests.docs.linkChecker.generateReport = function (that) {
    var errors = [];
    fluid.each(that.brokenLinks, function (link) {
        var pagesWithLink = that.pagesWithLink[link];
        fluid.each(pagesWithLink, function (pageWithLink) {
            errors.push({ link: link, page: pageWithLink });
        });
    });

    errors.sort(function (a, b) {
        if (a.page === b.page) {
            if (a.link === b.link) {
                return 0;
            }
            else if (a.link < b.link) {
                return -1;
            }
            else {
                return 1;
            }
        }
        else if (a.page < b.page) {
            return -1;
        }
        else {
            return 1;
        }
    });

    return { errors: errors };
};

fluid.tests.docs.linkChecker.processSingleResponse = function (that, pageToScan, error, response, body) {
    var pageResults = { statusCode: response.statusCode};
    if (error) {
        pageResults.error = error;
    }
    else if (body) {
        var dom = new jsdom.JSDOM(body);

        // Add the page's elements with IDs to our map of known placeholders.
        var pageIdNodeList = dom.window.document.querySelectorAll("[id]");
        var pageIds = [];
        for (var b = 0; b < pageIdNodeList.length; b++) {
            pageIds.push(pageIdNodeList.item(b).id);
        }
        that.idsByPage[pageToScan] = pageIds;

        var linksNodeList = dom.window.document.querySelectorAll("a[href]");
        for (var a = 0; a < linksNodeList.length; a++) {
            var link = linksNodeList.item(a);
            var href = link.href;

            if (href && href.length) {
                var resolvedHref = fluid.tests.docs.linkChecker.resolveSafely(pageToScan, href);
                if (!that.pagesWithLink[resolvedHref]) { that.pagesWithLink[resolvedHref] = []; }
                if (that.pagesWithLink[resolvedHref].indexOf(pageToScan) === -1) {
                    that.pagesWithLink[resolvedHref].push(pageToScan);
                }

                var linkBeforeHash = fluid.tests.docs.linkChecker.urlBeforeHash(resolvedHref);
                var linkAfterHash  = fluid.tests.docs.linkChecker.urlAfterHash(resolvedHref);

                // As long as this is a placeholder link somewhere within the site, hold on to it to check later.
                if (linkAfterHash.length && resolvedHref.indexOf(that.options.baseUrl) === 0) {
                    that.internalLinksToCheck.push(resolvedHref);
                }

                // Links to other pages within the site, including subdirectories.  Add new links to the queue.
                if (linkBeforeHash !== pageToScan && resolvedHref.indexOf(that.options.baseUrl) === 0) {
                    if (that.pagesToScan.indexOf(linkBeforeHash) === -1) {
                        that.pagesToScan.push(linkBeforeHash);
                    }
                }
                // External and loopback links are ignored.
                else {
                    // fluid.log("Ignoring link '", resolvedHref, "'...");
                }
            }
        }
    }

    that.scannedPages[pageToScan] = pageResults;
};

fluid.defaults("fluid.tests.docs.linkChecker", {
    gradeNames: ["fluid.component"],
    members: {
        idsByPage:            {}, // A map of id linked by page, so that we can check each unique id only once.
        internalLinksToCheck: [], // An array of internal links (i.e. "#internal-heading-id") detected during our scan.
        pagesToScan:          [], // An array of pages that still need to be scanned.
        pagesWithLink:        [], // An array of pages that contain a given link (used in reporting errors).
        brokenLinks:          [], // An array of broken links detected during the run.
        scannedPages:         {}  // A map of all the pages we've already scanned.
    },
    events: {
        onResultsAvailable: null
    },
    invokers: {
        startScan: {
            funcName: "fluid.tests.docs.linkChecker.startScan",
            args:     ["{that}"]
        },
        scanSinglePageOrFinish: {
            funcName: "fluid.tests.docs.linkChecker.scanSinglePageOrFinish",
            args:     ["{that}"]
        }
    }
});
