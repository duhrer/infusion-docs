/* globals Fuse */
(function (fluid) {
    "use strict";
    fluid.registerNamespace("fluid.docs.search");

    /**
     * Process the pre-generated digest created using src/scripts/create-search-digest.js.
     *
     * @param {Object} that - The search component itself.
     *
     */
    fluid.docs.search.processDigest = function (that) {
        var preIndexTime = Date.now();
        that.fuse = new Fuse(fluid.docs.search.digest, that.options.fuseOptions);
        fluid.log("Indexed in " + (Date.now() - preIndexTime) + " ms");
    };

    /**
     *
     * Search for the query string, then issue a call to display the results.  The raw results generated by Fuse.js are
     * grouped by page and ordered by the most relevant result for each individual page.
     *
     * @param {Object} that - The search component itself.
     *
     */
    fluid.docs.search.performSearch = function (that) {
        if (that.fuse && that.model.qs && that.model.qs.length) {
            var preSearchTime = Date.now();
            var rawSearchResults = that.fuse.search(that.model.qs);

            // Use a map keyed by path to check for uniqueness and group results
            var resultsByPage = {};

            // Use an array storing individual grouped path entries to preserve the search order, as in:
            var orderedResults = [];

            fluid.each(rawSearchResults, function (rawSearchResult) {
                var pageEntry = resultsByPage[rawSearchResult.item.pagePath];
                if (!pageEntry) {
                    pageEntry = {
                        pagePath:    rawSearchResult.item.pagePath,
                        pageTitle:   rawSearchResult.item.pageTitle,
                        pageResults: []
                    };
                    resultsByPage[rawSearchResult.item.pagePath] = pageEntry;
                    orderedResults.push(pageEntry);
                }

                var itemWithHighlights = fluid.docs.search.highlightBody(rawSearchResult.item, rawSearchResult.matches);
                pageEntry.pageResults.push(itemWithHighlights);
            });

            fluid.docs.search.displayResults(that, orderedResults, rawSearchResults.length);
            fluid.log("Search completed in " + (Date.now() - preSearchTime) + " ms");
        }
        else {
            var resultsElement = that.locate("searchResults");
            resultsElement.html(that.options.messages.noQuery);
        }
    };

    /**
     * @typedef searchHit - A single "search hit".
     * @property {String} body - A trimmed and highlighted representation of the longest match in this "hit" in context.
     * @property {String} headingId - If the search is associated with a linkable subheading, its ID (used for deep linking).
     * @property {String} headingText - If the search is associated with a linkable subheading, its text, otherwise the page title.
     * @property {String} pagePath - The relative path to the page within the site.
     * @property {String} pageTitle - The page's title.
     *
     * @typedef pageHits - A grouping of search hits on a single page.
     * @property {String} pagePath - The relative path to the page within the site.
     * @property {Array<searchHit>} pageResults - The full list of search hits for this page, in order of relevance.
     * @property {String} title - The page's title.
     *
     * @typedef fuseMatch - A single piece of "match" data to locate a search hit in context, as returned by Fuse.js.
     * @property {String} key - The field name of the matching field (always "body" in our case).
     * @property {String} value - The full content that was searched.
     * @property {Array<Array<Integer>>} indices - An array of two element vectors representing the start and end of a search hit in context.
     *
     */

    /**
     *
     * Generate HTML output based on a set of search results and string templates.
     *
     * @param {Object} that - The search component itself.
     * @param {Array<pageHits>} orderedAndGroupedResults - The search results generated by `fluid.docs.search.performSearch`.
     * @param {Integer} resultsCount - The total number of individual search hits within all grouped entries.
     *
     */
    fluid.docs.search.displayResults = function (that, orderedAndGroupedResults, resultsCount) {
        var resultsElement = that.locate("searchResults");
        var htmlOutput = fluid.stringTemplate(that.options.templates.header, { pages: orderedAndGroupedResults.length, results: resultsCount });
        fluid.each(orderedAndGroupedResults, function (pageEntry) {
            var singlePageHtml = "";

            if (pageEntry.pageResults.length === 1) {
                singlePageHtml += fluid.stringTemplate(that.options.templates.pageSingleResultSummary, pageEntry.pageResults[0]);
            }
            else if (pageEntry.pageResults.length > 1) {
                var allEntriesHtml = "";
                fluid.each(pageEntry.pageResults.slice(1), function (singleResult) {
                    var singleRowHtml = fluid.stringTemplate(that.options.templates.pageItem, singleResult);
                    allEntriesHtml += singleRowHtml;
                });

                var combinedData = fluid.extend({}, pageEntry.pageResults[0], { count: (pageEntry.pageResults.length - 1), allEntries: allEntriesHtml });
                var pageSummaryHtml = fluid.stringTemplate(that.options.templates.pageMultiResultSummary, combinedData);
                singlePageHtml += pageSummaryHtml;
            }

            htmlOutput += singlePageHtml;
        });

        htmlOutput += fluid.stringTemplate(that.options.templates.footer, orderedAndGroupedResults);
        resultsElement.html(htmlOutput);

        // Adapted from: https://github.com/fluid-project/infusion/blob/master/src/framework/preferences/js/Panels.js#L147
        var userJQuery = that.container.constructor;
        that.container = userJQuery(that.container.selector, that.container.context);
        that.dom.clear();

        that.events.onRender.fire();
    };

    /**
     *
     * A wrapper to only call a given callback if desired keys (such as the space and enter keys are pressed).
     *
     * @param {Array<Integer>} activeKeys - The keys we care about.  These are jQuery key codes.
     * @param {Object} event - The jQuery event object, which contains information about the target element, key pressed, et cetera.
     * @param {Function} callback - The function to call if the user pressed one of the desired keys.
     * @param {Array} callbackArgs - Arguments to pass to the callback.
     *
     */
    fluid.docs.search.filterByKeyPress = function (activeKeys, event, callback, callbackArgs) {
        if (activeKeys.indexOf(event.keyCode) !== -1) {
            event.preventDefault();
            callback.apply(null, fluid.makeArray(callbackArgs));
        }
    };

    /**
     *
     * A function that finds the longest match within a given piece of content based on the match indices provided by
     * Fuse.js.  The content is then trimmed to the nearest enclosing tag if available, so that we have a highlighted
     * search hit within a relatively small piece of context.
     *
     * @param {searchHit} singleSearchResult - A single "search hit".
     * @param {Array<fuseMatch>} matches - An array of indices representing the location of search hits in context.
     * @return {String} - The original body, with the longest match highlighted and the content trimmed to the nearest tag enclosing the longest match.
     */
    fluid.docs.search.highlightBody = function (singleSearchResult, matches) {
        var updatedSearchResult = fluid.copy(singleSearchResult);

        // find the longest match from all indexes.
        var longestMatchCoordinates = false;
        var longestMatchLength  = 0;
        fluid.each(matches, function (match) {
            fluid.each(match.indices, function (matchCoordinates) {
                var matchLength = matchCoordinates[1] - matchCoordinates[0];
                if (matchLength > longestMatchLength) {
                    longestMatchLength = matchLength;
                    longestMatchCoordinates = matchCoordinates;
                }
            });
        });

        // Highlight longest match, and trim to the nearest enclosing tag.
        if (longestMatchLength) {
            var startIndex = longestMatchCoordinates[0];
            var endIndex   = longestMatchCoordinates[1];
            var leader = singleSearchResult.body.substring(0, startIndex);
            var lastTagInLeader = leader.lastIndexOf(">");
            if (lastTagInLeader !== -1) {
                leader = leader.substring(lastTagInLeader + 1);
            }

            var matchText = singleSearchResult.body.substring(startIndex, (endIndex + 1));

            var trailer = singleSearchResult.body.substring(endIndex + 1);
            var firstTagInTrailer = trailer.indexOf("<");
            if (firstTagInTrailer !== -1) {
                trailer = trailer.substring(0, firstTagInTrailer);
            }

            var markedBody = leader + "<mark>" + matchText + "</mark>" + trailer;
            updatedSearchResult.body = markedBody;
        }

        return updatedSearchResult;
    };

    /**
     *
     * Search results are grouped by page, and by default only the most relevant result per page is displayed.  This
     * function powers a "toggle" that can be use to expand/close the "extended results" for a given page.
     *
     * @param {Object} that - The search component itself.
     * @param {Object} event - The jQuery event object, which includes the "target element" we need.
     *
     */
    fluid.docs.search.toggleExtendedResults = function (that, event) {
        event.preventDefault();
        // Tree back out to our grandparent and look down from there.
        var containingElement = $(event.target).parent().parent();
        var extendedResultsElement = $(containingElement).find(".search-extended-results");
        extendedResultsElement.toggleClass("hidden");
    };

    fluid.defaults("fluid.docs.search", {
        gradeNames: ["gpii.locationBar", "gpii.binder.bindOnCreate", "fluid.viewComponent"],
        fuseOptions: {
            shouldSort: true,   // Sort by relevance, i.e. how well the content matches the search terms.
            /*
                Each digest segment "body" contains a heading's-worth of rendered markdown.  See
                src/scripts/create-search-digest.js for details.
            */
            keys: ["body"],
            includeMatches: true, // Include the index of matching content so that we can highlight matches.
            includeScore: true,   // Include the relevance score (0 = perfect match, 1 = no similarity) in the results.
            threshold: 0.1,       // Filter to only display search results that match at this level or better (lower).
            distance: 10000       // We use a low threshold and a high distance so that we have to more exactly match the search strings.

        },
        events: {
            onRender: null
        },
        messages: {
            noQuery: "<p>Enter one or more search terms and press enter to search.</p>"
        },
        // TODO: Discuss our long term rendering strategy WRT Hugo, future Fluid, etc. and break this out better.
        templates: {
            header:     "<p>Displaying %results matching search results from %pages pages.</p>\n",
            pageMultiResultSummary: "<div class=\"search-result-single-page\"><h3><a href=\"%pagePath#%headingId\" target=\"_blank\">%pageTitle &gt; %headingText</a></h3><p class=\"search-context-highlight\">%body</p><p>Showing most relevant result, there are <a class=\"search-extended-results-toggle\" href=\"#\">%count additional entries</a> on the same page.</p> <div class=\"search-extended-results hidden\">\n%allEntries</div></div> \n",
            pageSingleResultSummary: "<div class=\"search-result-single-page\"><h3><a href=\"%pagePath#%headingId\" target=\"_blank\">%pageTitle &gt; %headingText</a></h3><p class=\"search-context-highlight\">%body</p></div> \n",
            pageItem: "<div class=\"search-result-sub-entry\"><h5><a href=\"%pagePath#%headingId\" target=\"_blank\">%pageTitle &gt; %headingText</a></h5><p class=\"search-context-highlight\">%body</p></div> \n",
            footer:     ""
        },
        selectors: {
            queryInput: ".docs-search-query",
            searchResults: ".docs-search-results",
            extendedResultsToggle: ".search-extended-results-toggle"
        },
        model: {
            qs: ""
        },
        bindings: {
            "queryInput": "qs"
        },
        members: {
            fuse: false
        },
        invokers: {
            search: {
                funcName: "fluid.docs.search.performSearch",
                args: ["{that}"]
            },
            toggleExtendedResults: {
                funcName: "fluid.docs.search.toggleExtendedResults",
                args: ["{that}", "{arguments}.0"] // event
            },
            toggleOnKeyPress: {
                funcName: "fluid.docs.search.filterByKeyPress",
                args: [[13, 32], "{arguments}.0", "{that}.toggleExtendedResults", ["{arguments}.0"]] // activeKeys, event, callback, callbackArgs
            }
        },
        listeners: {
            "onCreate.processDigest": {
                funcName: "fluid.docs.search.processDigest",
                args: ["{that}"]
            },
            "onCreate.search": {
                func: "{that}.search"
            },

            // Toggle "extended results".
            "onRender.bindExtendedResultsToggleKeys": {
                "this": "{that}.dom.extendedResultsToggle",
                method: "keypress",
                args: ["{that}.toggleOnKeyPress"]
            },
            "onRender.bindExtendedResultsToggleClick": {
                "this": "{that}.dom.extendedResultsToggle",
                method: "click",
                args: ["{that}.toggleExtendedResults"]
            }
        },
        modelListeners: {
            "qs": {
                func: "{that}.search"
            }
        }
    });
})(fluid);
